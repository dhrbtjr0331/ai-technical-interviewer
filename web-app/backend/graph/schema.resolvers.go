package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"ai-interviewer-bff/graph/model"
	"context"
	"fmt"
	"time"
)

// StartInterview is the resolver for the startInterview field.
func (r *mutationResolver) StartInterview(ctx context.Context, userID string, difficulty string) (*model.Interview, error) {
	// Call the agent service to start interview
	resp, err := r.AgentService.StartInterview(userID, difficulty)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	return &model.Interview{
		ID:         resp.SessionID,
		SessionID:  resp.SessionID,
		UserID:     resp.UserID,
		Difficulty: difficulty,
		Status:     resp.Status,
		StartedAt:  time.Now().Format(time.RFC3339),
		Messages:   []*model.Message{},
	}, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, sessionID string, content string) (*model.Message, error) {
	resp, err := r.AgentService.SendMessage(sessionID, content)
	if err != nil {
		return nil, err
	}

	return &model.Message{
		ID:          resp.MessageID,
		SessionID:   sessionID,
		Speaker:     "user",
		Content:     content,
		Timestamp:   time.Now().Format(time.RFC3339),
		MessageType: "text",
	}, nil
}

// SubmitCode is the resolver for the submitCode field.
func (r *mutationResolver) SubmitCode(ctx context.Context, sessionID string, code string, language string) (*model.CodeSubmission, error) {
	_, err := r.AgentService.SubmitCode(sessionID, code, language)
	if err != nil {
		return nil, err
	}

	return &model.CodeSubmission{
		SessionID: sessionID,
		Code:      code,
		Language:  language,
		Timestamp: time.Now().Format(time.RFC3339),
	}, nil
}

// ExecuteCode is the resolver for the executeCode field.
func (r *mutationResolver) ExecuteCode(ctx context.Context, sessionID string) (*model.ExecutionResult, error) {
	resp, err := r.AgentService.ExecuteCode(sessionID)
	if err != nil {
		return nil, err
	}

	return &model.ExecutionResult{
		SessionID:     sessionID,
		Output:        resp.Output,
		ExitCode:      0,
		ExecutionTime: 0.0,
		Timestamp:     time.Now().Format(time.RFC3339),
	}, nil
}

// EndInterview is the resolver for the endInterview field.
func (r *mutationResolver) EndInterview(ctx context.Context, sessionID string) (*model.Interview, error) {
	err := r.AgentService.EndInterview(sessionID)
	if err != nil {
		return nil, err
	}

	status, err := r.AgentService.GetInterviewStatus(sessionID)
	if err != nil {
		return nil, err
	}

	return &model.Interview{
		ID:        sessionID,
		SessionID: sessionID,
		UserID:    status.UserID,
		Status:    "ended",
		StartedAt: time.Now().Format(time.RFC3339),
		EndedAt:   stringPtr(time.Now().Format(time.RFC3339)),
		Messages:  []*model.Message{},
	}, nil
}

func stringPtr(s string) *string {
	return &s
}

// DeleteInterview is the resolver for the deleteInterview field.
func (r *mutationResolver) DeleteInterview(ctx context.Context, sessionID string) (bool, error) {
	err := r.AgentService.EndInterview(sessionID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// Interview is the resolver for the interview field.
func (r *queryResolver) Interview(ctx context.Context, sessionID string) (*model.Interview, error) {
	status, err := r.AgentService.GetInterviewStatus(sessionID)
	if err != nil {
		return nil, err
	}

	messages := make([]*model.Message, len(status.Messages))
	for i, msg := range status.Messages {
		messages[i] = &model.Message{
			ID:          msg.ID,
			SessionID:   sessionID,
			Speaker:     msg.Speaker,
			Content:     msg.Content,
			Timestamp:   msg.Timestamp.Format(time.RFC3339),
			MessageType: msg.Type,
		}
	}

	return &model.Interview{
		ID:        sessionID,
		SessionID: sessionID,
		UserID:    status.UserID,
		Status:    status.Status,
		StartedAt: time.Now().Format(time.RFC3339),
		Messages:  messages,
	}, nil
}

// Interviews is the resolver for the interviews field.
func (r *queryResolver) Interviews(ctx context.Context, userID string, limit *int, offset *int) ([]*model.Interview, error) {
	// TODO: Implement database query for user's interviews
	// For now, return empty list
	return []*model.Interview{}, nil
}

// Messages is the resolver for the messages field.
func (r *queryResolver) Messages(ctx context.Context, sessionID string, limit *int, offset *int) ([]*model.Message, error) {
	status, err := r.AgentService.GetInterviewStatus(sessionID)
	if err != nil {
		return nil, err
	}

	messages := make([]*model.Message, 0, len(status.Messages))
	for _, msg := range status.Messages {
		messages = append(messages, &model.Message{
			ID:          msg.ID,
			SessionID:   sessionID,
			Speaker:     msg.Speaker,
			Content:     msg.Content,
			Timestamp:   msg.Timestamp.Format(time.RFC3339),
			MessageType: msg.Type,
		})
	}

	return messages, nil
}

// Problems is the resolver for the problems field.
func (r *queryResolver) Problems(ctx context.Context, difficulty *string, limit *int) ([]*model.Problem, error) {
	// TODO: Implement database query for problems
	// For now, return empty list
	return []*model.Problem{}, nil
}

// Problem is the resolver for the problem field.
func (r *queryResolver) Problem(ctx context.Context, id string) (*model.Problem, error) {
	// TODO: Implement database query for specific problem
	return nil, fmt.Errorf("problem not found")
}

// MessageAdded is the resolver for the messageAdded field.
func (r *subscriptionResolver) MessageAdded(ctx context.Context, sessionID string) (<-chan *model.Message, error) {
	ch := make(chan *model.Message, 1)

	// Register subscription
	r.subscribersMu.Lock()
	if r.subscribers[sessionID] == nil {
		r.subscribers[sessionID] = make(map[chan interface{}]bool)
	}
	genericCh := make(chan interface{}, 1)
	r.subscribers[sessionID][genericCh] = true
	r.subscribersMu.Unlock()

	// Forward messages from generic channel to typed channel
	go func() {
		defer close(ch)
		for {
			select {
			case <-ctx.Done():
				r.unsubscribe(sessionID, genericCh)
				return
			case msg, ok := <-genericCh:
				if !ok {
					return
				}
				if typedMsg, ok := msg.(*model.Message); ok {
					ch <- typedMsg
				}
			}
		}
	}()

	return ch, nil
}

// InterviewUpdated is the resolver for the interviewUpdated field.
func (r *subscriptionResolver) InterviewUpdated(ctx context.Context, sessionID string) (<-chan *model.Interview, error) {
	ch := make(chan *model.Interview, 1)
	// TODO: Implement real-time interview updates
	go func() {
		<-ctx.Done()
		close(ch)
	}()
	return ch, nil
}

// CodeAnalysisCompleted is the resolver for the codeAnalysisCompleted field.
func (r *subscriptionResolver) CodeAnalysisCompleted(ctx context.Context, sessionID string) (<-chan *model.CodeAnalysis, error) {
	ch := make(chan *model.CodeAnalysis, 1)
	// TODO: Implement real-time code analysis updates
	go func() {
		<-ctx.Done()
		close(ch)
	}()
	return ch, nil
}

// ExecutionCompleted is the resolver for the executionCompleted field.
func (r *subscriptionResolver) ExecutionCompleted(ctx context.Context, sessionID string) (<-chan *model.ExecutionResult, error) {
	ch := make(chan *model.ExecutionResult, 1)
	// TODO: Implement real-time execution result updates
	go func() {
		<-ctx.Done()
		close(ch)
	}()
	return ch, nil
}

func (r *Resolver) unsubscribe(sessionID string, ch chan interface{}) {
	r.subscribersMu.Lock()
	defer r.subscribersMu.Unlock()
	if r.subscribers[sessionID] != nil {
		delete(r.subscribers[sessionID], ch)
		close(ch)
		if len(r.subscribers[sessionID]) == 0 {
			delete(r.subscribers, sessionID)
		}
	}
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
